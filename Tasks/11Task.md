1. Для начала - воспользуемся предоставленным скриптом и создадим исходные данные.
1. Теперь нужно продумать логически - что требуется от работу триггера:
	1. При продаже - увеличивать сумму продаж.
	1. При отмене продажи - уменьшать ее.
	1. При изменении - уменьшить старую сумму(цену старого товара), прибавить новую - по сути комбинация удаления и создания.
1. (*****)До начала выполнения задачи - сразу хочется отметить, что логика будет предусматривать изменение и удалении продажи ТОЛЬКО до смены цены товара - в ином случае - расчет будет некорректным. Так как будет удалена уже новая стоимость товара. В таких случаях обычно сохраняют стоимость товара в данных о продаже - тогда отмена продажи, или ее корректировка проблем не вызывают.
	Так же этот пункт сильно затрагивает** задание со звездочкой(*)** - в нем предполагается, что мы будем хранить всегда актуальные суммы продаж, несмотря на изменение цен. Т.е.. Если мы продали товар за 100 руб., а цена стала - 150 руб. - то в данной таблице, в отличии от отчета генерируемого командой - будет корректна учтена актуальная на тот момент цена - 100 руб, а не актуальная на текущий момент - 150 руб. Но назвать этот момент приемуществом триггера относительно генерации отчета "по запросу" нельзя, так как подобная ситуация является следствием проблем на уровне проектирования БД. Триггер будет приоритетней только в случае, если получение данных "витрины" будет производиться очень часто - в остальных случаях, если подобная аналитика будет нужна редко - смысла нагружать добавление данных в таблицу продаж триггером - мало.
4. Первым делом - предлагаю установить название товара в таблице `good_sum_mart` в качестве первичного ключа (по хорошему хранить ID товара, а не имя) - так мы сможем быстро получить доступ к требуемым нам данным.
```Sql
ALTER TABLE good_sum_mart ADD PRIMARY KEY (good_name);
```
5. Детальная проработка триггера:
	1. При **удалении**, или **обновлении** сущности:
		1. Берем старое значение наименования и цены (получаем данные о товаре).
		1. Вычитаем из записи в таблице `good_sum_mart` старую сумму (делаем выборку по старому наименованию).
		1. Если при обновлении не удалось найти запись - создаем запись с минусом.
	2. При **добавлении**, или **обновлении** сущности.
		1. Берем старое значение наименования и цены (получаем данные о товаре)
		1. Прибавляем к записи в таблице `good_sum_mart` сумму продажи.
		1. Если записи не существует (обновление завершилось ошибкой) - создаем запись по наименованию товара с суммой продажи.
6. Пишем функцию для триггера:
	```Sql
	CREATE OR REPLACE FUNCTION pract_functions.sales_trigger()
	RETURNS TRIGGER AS $$
	DECLARE
	    old_price numeric(12,2);
	    old_name varchar(63);
	    new_price numeric(12,2);
	    new_name varchar(63);
	BEGIN
	    -- Обработка DELETE/UPDATE: получаем старые значения
	    IF (TG_OP = 'DELETE' OR TG_OP = 'UPDATE') THEN
			-- Получаем данные о товаре.
	        SELECT good_price, good_name INTO old_price, old_name
	        FROM goods WHERE goods_id = OLD.good_id;
	
	        -- Обновление витрины для старого товара
	        UPDATE good_sum_mart 
	        SET sum_sale = sum_sale - (OLD.sales_qty * old_price)
	        WHERE good_name = old_name;
	        
	        -- Если запись отсутствует, создаем новую запись в витрине.
	        IF NOT FOUND THEN
	            INSERT INTO good_sum_mart (good_name, sum_sale)
	            VALUES (old_name, - (OLD.sales_qty * old_price));
	        END IF;
	    END IF;
	
	    -- Обработка INSERT/UPDATE: получаем новые значения
	    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
			-- Получаем данные о товаре.
	        SELECT good_price, good_name INTO new_price, new_name
	        FROM goods WHERE goods_id = NEW.good_id;
	
	        -- Обновление витрины для нового товара
	        UPDATE good_sum_mart 
	        SET sum_sale = sum_sale + (NEW.sales_qty * new_price)
	        WHERE good_name = new_name;
	        
			-- Если запись отсутствует, создаем новую запись в витрине.
	        IF NOT FOUND THEN
	            INSERT INTO good_sum_mart (good_name, sum_sale)
	            VALUES (new_name, NEW.sales_qty * new_price);
	        END IF;
	    END IF;
	    RETURN NULL;
	END;
	$$ LANGUAGE plpgsql;
	CREATE FUNCTION
	```7. Создаем триггер.
```
CREATE TRIGGER sales_after_trigger
AFTER INSERT OR UPDATE OR DELETE ON sales
FOR EACH ROW EXECUTE FUNCTION pract_functions.sales_trigger();
```
8. Предварительно заполним данные на ветрине по всем более ранним продажам.
```
TRUNCATE good_sum_mart;

INSERT INTO good_sum_mart (good_name, sum_sale)
SELECT G.good_name, SUM(G.good_price * S.sales_qty)
FROM goods G
JOIN sales S ON G.goods_id = S.good_id
GROUP BY G.good_name;
```
9. Проведем тест.
	1. Создадим продажу.
		1. Витрина до создания.
		```
		postgres=# select * from good_sum_mart;
		        good_name         |   sum_sale
		--------------------------+--------------
		 Автомобиль Ferrari FXX K | 185000000.01
		 Спички хозайственные     |        65.50
		(2 rows)
		```
		2. Создание продажи.
		```
		postgres=# insert into sales(good_id, sales_qty) values (1, 10);
		INSERT 0 1
		```
		3. Витрина после создания.
		```
		postgres=# select * from good_sum_mart;
		        good_name         |   sum_sale
		--------------------------+--------------
		 Автомобиль Ferrari FXX K | 185000000.01
		 Спички хозайственные     |        70.50
		(2 rows)
		```2. Удалим продажу.
		1. Витрина до удаления.
		```
		postgres=# select * from good_sum_mart;
		        good_name         |   sum_sale
		--------------------------+--------------
		 Автомобиль Ferrari FXX K | 185000000.01
		 Спички хозайственные     |        70.50
		(2 rows)
		```
		2. Удаление продажи.
		```
		postgres=# delete from sales where sales_id = 5;
		DELETE 1
		```
		3. Витрина после удаления.
		```
		postgres=# select * from good_sum_mart;
		        good_name         |   sum_sale
		--------------------------+--------------
		 Автомобиль Ferrari FXX K | 185000000.01
		 Спички хозайственные     |        65.50
		(2 rows)
		```3. Изменение продажи.
		1. Витрина до изменения.
		```
		postgres=# select * from good_sum_mart;
		        good_name         |   sum_sale
		--------------------------+--------------
		 Автомобиль Ferrari FXX K | 185000000.01
		 Спички хозайственные     |        70.50
		(2 rows)
		```
		2. Изменение продажи.
		```
		postgres=# update sales set sales_qty = 5 where sales_id = 6;
		UPDATE 1
		```
		3. Витрина после изменения.
		```
		postgres=# select * from good_sum_mart;
		        good_name         |   sum_sale
		--------------------------+--------------
		 Автомобиль Ferrari FXX K | 185000000.01
		 Спички хозайственные     |        68.00
		(2 rows)
		```4. Проверим, что новый товар тоже корректно будет фиксироваться в продажах.
		1. Витрина до создания.
		```
		postgres=# select * from good_sum_mart;
		        good_name         |   sum_sale
		--------------------------+--------------
		 Автомобиль Ferrari FXX K | 185000000.01
		 Спички хозайственные     |        68.00
		(2 rows)
		```
		1. Создание продажи с новым товаром.
		```
		postgres=# insert into goods (goods_id, good_name, good_price) values (3, 'Носок черный', 10);
		INSERT 0 1
		postgres=# insert into sales(good_id, sales_qty) values (3, 7);
		INSERT 0 1
		```
		1. Витрина после создания.
		```
		postgres=# select * from good_sum_mart;
		        good_name         |   sum_sale
		--------------------------+--------------
		 Автомобиль Ferrari FXX K | 185000000.01
		 Спички хозайственные     |        68.00
		 Носок черный             |        70.00
		(3 rows)
		```1. Подведем итоги - логика триггера корректно работает и автоматически обновляет статистику.
	Реальная польза от такого триггера будет только если данная информация необходима постоянно (например отображается на главной странице сайта) - в иных случаях накладные расходы на обработку триггера при сохранении продажи - не стоят того.
	**Задание со звездочкой подробно разобрал в третьем(3) пункте отчета.**
